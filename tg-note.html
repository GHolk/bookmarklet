<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>note template - gholk</title>
<meta property="gholk:cite" content="https://gholk.github.io/bookmarklet/tg-note.html">
</head>
<body>
<main contenteditable="true"
><p>[p]</p>
<pre>[pre]</pre>
</main>
<div id="control-pane">
<label><input type="checkbox" checked
onchange="contentEditableToggle.call(this)">
toggle content editable</label>
<label><input type="checkbox" onchange="htmlToggle.call(this)">
show html</label>
<label><input type="checkbox"
onchange="keepLineBreakToggle.call(this)">
keep line break</label>

<label><input type="checkbox" checked
onchange="smartPasteToggle.call(this)">
smart paste</label>
(smart escape html special characters in html source code mode)

<label>cite url:
<input type="url" placeholder="cite url"
oninput="citeUrlUpdate.call(this)">
</label>

<button onclick="imageAdd()">add image</button>
<button onclick="digestCheckSumSet()">sha256</button>
</div>

<style contenteditable="true"
>:root {
  /* linux, mac, *, linux, windows, windows, * */
  --mono: "Liberation Mono", Monaco, "DejaVu Sans Mono", "Anonymous Pro", consolas, cascadia, monospace;
}
pre, code {
  font-family: var(--mono);
}
body > style {
  display: block;
  white-space: pre-wrap;
  color: gray;
  margin: 1ex;
  padding: 1ex;
  border: solid 1px;
  font-family: var(--mono);
}
pre.wrap {
  white-space: pre-line;
}
main.keep-line > p, main .keep-line {
  white-space: pre-line;
}
img {
  display: block;
  max-width: 100%;
}
blockquote {
  border: solid #CCC 1px;
  border-left: solid #CCC 1ex;
  padding: 0 1em;
  margin-left: 1ex;
}
label {
  display: flex;
}
main[contenteditable=true] > *:not(.html-code,hr,table,ul,ol)::before {
  color: gray;
  content: '<x>';
  font-family: var(--mono);
}
main[contenteditable=true] > *:not(.html-code,hr,table,ul,ol)::after {
  color: gray;
  content: '</>';
  font-family: var(--mono);
}
@media (min-width: 50rem) {
	#control-pane {
	  position: fixed;
	  bottom: 0;
	  right: 0;
	  background: white;
	  border: solid 1px;
	  padding: 1em;
	}
}
#control-pane > label > input[type=text],
#control-pane > label > input[type=url] {
  display: flex;
  flex: 1;
  margin-left: 1ex;
  font-family: var(--mono);
  font-variant-numeric: slashed-zero;
}
body {
  padding-bottom: 20em;
}
main, #control-pane {
  border: solid 1px;
  margin: 1ex;
  padding: 1ex;
}
table, th, td {
  border: solid 1px;
}
</style>
<script>
var d = document, $d = document,
    b = d.body, $b = $d.body;

function $(selector, context) {
    return (context || $d).querySelector(selector)
}
function $$(selector, context) {
    return Array.from((context || $d).querySelectorAll(selector))
}

function create(tag, parent = null) {
    const elm = $d.createElement(tag)
    if (parent !== null) (parent || $b).appendChild(elm);
    return elm;
}
function contentEditableToggle() {
  $('main').setAttribute('contenteditable', this.checked)
  if (this.checked) this.setAttribute('checked', '')
  else this.removeAttribute('checked')
}
function keepLineBreakToggle() {
  if (this.checked) {
    $('main').classList.add('keep-line')
    this.setAttribute('checked', '')
  }
  else {
    $('main').classList.remove('keep-line')
    this.removeAttribute('checked')
  }
}
function htmlToggle() {
  toggle = this.checked
  const toHtml = toggle
  const main = $('main')
  if (toHtml) {
    // TODO: indent html
    const html = main.innerHTML
    main.textContent = ''
    const pre = create('pre', main)
    pre.className = 'wrap html-code'
    pre.textContent = html
  }
  else {
    $$('main>pre>br').forEach(br =>
	  br.replaceWith(document.createTextNode('\n'))
	)
    const html = $('main>pre').textContent
    main.innerHTML = html
  }
}
document.addEventListener('selectionchange', event =>
  preventSelectHtmlBox(event)
)
// prevent delete code block in html source mode
function preventSelectHtmlBox(event) {
  const sel = $d.getSelection()
  if (sel.isCollapsed) return
  if (sel.anchorNode != sel.focusNode) return
  const node = sel.anchorNode
  if (node.nodeType != Node.ELEMENT_NODE) return
  const pre = node.children[0]
  if (!pre || !pre.matches('main>pre.html-code:only-child')) return
  if (sel.rangeCount != 1) return

  const r = sel.getRangeAt(0)
  r.selectNodeContents(pre)
}
function imageAdd() {
  const sw = $('input[onchange^=htmlToggle]')
  if (!sw.checked) {
    sw.checked = true
    sw.dispatchEvent(new Event('change'))
  }
  $('main>pre').textContent += '\n<img src="">\n'
}
function smartPasteToggle() {
  const smart = this.checked
  const main = $('main')
  if (smart) main.addEventListener('paste', smartPasteHandler)
  else main.removeEventListener('paste', smartPasteHandler)
}
smartPasteToggle.call({checked: true})
function smartPasteHandler(e) {
  if (!e.target.matches('main>pre.html-code:only-child')) return
  const data = e.clipboardData
  if (~data.types.indexOf('text/html')) {
    e.preventDefault()
    const html = data.getData('text/html')
    insertOnCursor(document.createTextNode(html))
  }
  if (data.types.length != 1 || data.types[0] != 'text/plain') return

  const text = data.getData('text')
  if (/[<>]/.test(text) || !/[&"']/.test(text)) return

  e.preventDefault()
  const node = create('span')
  node.textContent = text
  const escape = node.innerHTML
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
  insertOnCursor(document.createTextNode(escape))
}
function insertOnCursor(node) {
  const sel = document.getSelection()
  const range = sel.getRangeAt(0)
  range.deleteContents()
  range.insertNode(node)
  range.collapse()
}
function citeUrlUpdate() {
  const meta = $('meta[property="gholk:cite"]')
  meta.content = this.value
  this.setAttribute('value', this.value)
}
async function digestCheckSumSet() {
  const html = $('html').outerHTML
  const sum = await digestCheckSum(html)
  const hex = bufferToHex(sum)
  const field = $('input[oninput^="citeUrlUpdate"]')
  field.value += `?sha256=${hex}`
  citeUrlUpdate.call(field)
}
function digestCheckSum(text) {
  const enc = new TextEncoder()
  const data = enc.encode(text)
  return crypto.subtle.digest('SHA-256', data)
}
function bufferToHex(buffer) {
  const u8 = new Uint8Array(buffer)
  return Array.from(u8)
    .map(u => ('0' + u.toString(16)).slice(-2).toUpperCase())
	.join('')
}
$$('input').forEach(e => {
  switch (e.type) {
    case 'checkbox':
	e.checked = e.defaultChecked
	break
    
	case 'url':
	case 'text':
	e.value = e.defaultValue
  }
})
</script>
</body>
</html>
